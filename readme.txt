ru is our file extension abbreviation of "Roman Urdu". The compiler that we are going to make.
This readme file should contain the details, the pros and cons. Special cases. etc etc.
Provide "How to run your code" here too. 
Be specific about everything.
Code must be thoroughly commented
test your program thoroughly with provided test sample

Run code by using
1- make
2- ./a.out sample_code.ru
3- make clean

Tokens will be printed with indexes. Details about code are available in readme.txt

In this phase of developing a roman urdu compiler, we made dfa and RE for the language.Then using those, we
designed a lexical analyzer which tokenizes the ru code. We faced some difficulty while deciding on the
order to explore characters for tokenization, but then we realized keywords should be checked first as 
keywords could change into identifiers if more characters are added to them. Apart from that, we did not
face any issue as everything was well documented and explained in class.

In this second phase of developing our custom compiler, we first designed a cfg for our language. We then 
converted it into LL(1) form. The most difficult part was designing the cfg. Coding the cfg was easy but lengthy.
When the cfg was finally coded, all we did was compare the tokens generated by lexer according to our cfg. 

In the third phase of developing compiler for roman urdu, we added output actions to the cfg ,created in the last
phase, to generate three address code which is functionally equivalent to our source code. Moreover, additional
information was added to symbol table. This was a relatively easy deliverable compared to previous ones as cfg was
already created and only output actions and their implementation in code was added.

In the fourth and final phase of the assignment, we made a virtual machine to execute the machine code instructions
generated by our code. First, we generated the machine code and saved it to a file named "mce.txt". Machine code was
generated by adding output actions to the cfg. This was a tricky part. Later, we designed a virtual machine to read
the file containing machine code "mce.txt" line by line and execute those instructions.